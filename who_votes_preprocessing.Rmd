---
title: "Data Preprocessing"
author: "Justina Zou"
date: "10/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Libraries

```{r}
library(tidyverse)
library(stringr)
library(stringi)
library(rjags)
library(R2jags)
```

# Read and merge

Copied from who_votes_eda.Rmd.

```{r}
voter_small = readRDS("ncvoter_Statewide_small.rds") %>%
  filter(birth_age <= 116) %>%
  dplyr::select(-birth_year, -status_cd, -reason_cd)

hist_small = readRDS("ncvhis_Statewide_small.rds") %>%
  filter(election_desc == "11/08/2016 GENERAL") %>%
  dplyr::select(-election_lbl, -voted_party_cd, -pct_label, -voted_county_id, -vtd_label)

hist_small_not_dup =  hist_small[!duplicated(hist_small$ncid),]

# process median income data
median_inc_county = read.csv("median_household_incomes_NC.csv") %>%
  mutate(county = str_replace(county, " County", "")) %>%
  mutate(county = toupper(county))

voter_hist = merge(voter_small, hist_small_not_dup, by = "ncid", all.x = TRUE)

voter_hist_county = merge(voter_hist, median_inc_county, by.x = "county_desc.x", by.y = "county", all.x = TRUE)

voter_hist_filtered = voter_hist_county
#rm(voter_small, hist_small)
```

# Fix missing cong_dist_abbrv

## How many are missing, and how many can't be resolved?

```{r}
nrow(voter_hist_filtered %>% 
  filter(is.na(cong_dist_abbrv)))

cant_borrow <- voter_hist_filtered %>% 
  group_by(county_desc.x, cong_dist_abbrv) %>% 
  summarise(n=n()) %>% 
  group_by(county_desc.x) %>%
  summarise(n=n()) %>% 
  filter(n>2) %>% 
  select(county_desc.x)
cant_borrow <- cant_borrow$county_desc.x

nrow(voter_hist_filtered %>% 
       filter(is.na(cong_dist_abbrv)) %>% 
       filter(county_desc.x %in% cant_borrow))

nrow(voter_hist_filtered %>% 
       filter(is.na(cong_dist_abbrv)) %>% 
       filter(county_desc.x %in% cant_borrow)) / nrow(voter_hist_filtered)
```

## Let's resolve the ones we can

```{r}
can_borrow <- voter_hist_filtered %>% 
  group_by(county_desc.x, cong_dist_abbrv) %>% 
  summarise(n=n()) %>% 
  group_by(county_desc.x) %>%
  summarise(n=n()) %>% 
  filter(n==2) %>% 
  select(county_desc.x)
can_borrow <- can_borrow$county_desc.x
can_borrow <- as.character(can_borrow)

# Create a map from county to district
# Match by county because it's much less likely 
# for everyone in a county to only come from one district
# while zip codes might result in false matches
county2district <- voter_hist_filtered %>% 
  filter(county_desc.x %in% can_borrow,
         !is.na(cong_dist_abbrv)) %>% 
  select(county_desc.x, cong_dist_abbrv) %>% 
  unique()
row.names(county2district) <- county2district$county_desc.x
county2district$county_desc.x <- as.character(county2district$county_desc.x)

voter_hist_districts <- voter_hist_filtered %>% 
  mutate(county_desc.x = as.character(county_desc.x)) %>%
  mutate(cong_dist_abbrv = case_when(
    !is.na(cong_dist_abbrv) ~ as.integer(cong_dist_abbrv),
    county_desc.x %in% can_borrow ~ as.integer(county2district[as.character(county_desc.x), 2]),
    TRUE ~ as.integer(NA)
  )) %>% 
  mutate(cong_dist_abbrv = as.factor(cong_dist_abbrv))
still_missing_zipcodes <- voter_hist_districts %>% 
  filter(is.na(cong_dist_abbrv))
still_missing_zipcodes <- still_missing_zipcodes$zip_code
# Most zip codes are missing
```

# Filter missing districts

```{r}
voter_hist_districts <- voter_hist_districts %>% 
  filter(!is.na(cong_dist_abbrv))
```

# Remove duplicate columns from merging

```{r, eval = F}
voter_hist_districts <- voter_hist_districts %>% 
  select(-c("county_desc.y", "county_id.y", "voter_reg_num.x", "voter_reg_num.y")) %>% 
  rename(county_desc = county_desc.x, 
         county_id = county_id.x)
```

# create response column

```{r}
voter_hist_districts_resp = voter_hist_districts %>%
  mutate(vote_or_not = case_when(
    is.na(election_desc) ~ 0,
    TRUE ~ 1
  )) %>%
  mutate(med_household_income = scale(med_household_income, center= TRUE, scale = TRUE)) %>% select(-county_id, -zip_code, -drivers_lic, -vtd_description, -election_desc)
  
```

# Write to rds

```{r}
# ask amy about reproducibility
saveRDS(voter_hist_districts_resp, "filtered_ncvoterhis_resp.rds")
```

# IMPORT rds
```{r}
voter_hist_districts_resp = readRDS("filtered_ncvoterhis_resp.rds")
```

# eda

```{r}
density_age_party <- ggplot(merge_small_samp, aes(birth_age,color=voted_party_cd)) + labs(y="Density", x = "Age", title = "Marginal Density for Ages \n of Different Party Voters", caption = "Figure 1") + geom_density(alpha=.5)  +theme(plot.title = element_text(hjust = 0.5))
stacked_race_party <- ggplot(merge_small_samp, aes(race_code,fill=voted_party_cd)) + labs(y="Density", x = "Age", title = "Race v. Party", caption = "Figure 1")+ geom_bar( position="fill", stat="count") + theme(plot.title = element_text(hjust = 0.5))
stacked_county_party <- ggplot(merge_small_samp, aes(county_id.x,fill=voted_party_cd)) + labs(y="Density", x = "County", title = "County v. Party", caption = "Figure 1")+ geom_bar( position="fill", stat="count") + theme(plot.title = element_text(hjust = 0.5))
stacked_county_race <- ggplot(merge_small_samp, aes(county_id.x,fill=race_code)) + labs(y="Density", x = "County", title = "County v. Race", caption = "Figure 1")+ geom_bar( position="fill", stat="count") + theme(plot.title = element_text(hjust = 0.5))
stacked_state_race <- ggplot(merge_small_samp, aes(birth_state,fill=race_code)) + labs(y="Density", x = "Birth State", title = "Birth State v. Race", caption = "Figure 1")+ geom_bar( position="fill", stat="count") + theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
box_age_race <- ggplot(merge_small_samp, aes(x=race_code, y=birth_age)) + geom_boxplot() + labs(y="Age", x = "Race", title = "Age v. Races", caption = "Figure 2")  +theme(plot.title = element_text(hjust = 0.5)) 
```

# build simple glm model

```{r}
#voter_hist_districts_resp = readRDS("filtered_ncvoterhis_resp.rds") 

voter_hist_districts_resp_small = sample_n(voter_hist_districts_resp, 100000)

formula = vote_or_not ~ party_cd + race_code + gender_code + birth_age + cong_dist_abbrv 
prelim_logit_model = glm(formula = formula, family = "binomial", data = voter_hist_districts_resp_small)
```

# checking accuracy for the simple glm model

```{r}
# ideally should use test dataset for predict()
prelim_logit_model.probs <- predict(prelim_logit_model, voter_hist_districts_resp_small, type = "response")
prelim_logit_model.pred <- rep("0", nrow(voter_hist_districts_resp_small))
prelim_logit_model.pred[prelim_logit_model.probs > 0.5] <- 1 # if prob > 0.5, predicted vote_or_not is 1

conf.matrix <- table(prelim_logit_model.pred, voter_hist_districts_resp_small$vote_or_not)
conf.matrix

sum(diag(conf.matrix)/nrow(voter_hist_districts_resp_small))
```

# test-train split

```{r}
# THIS IS FOR DEBUGGING PURPOSES ONE SPLIT
## 75% of the sample size
smp_size <- floor(0.80 * nrow(voter_hist_districts_resp_small))

## set the seed to make your partition reproducible
set.seed(123)
train_ind <- sample(seq_len(nrow(voter_hist_districts_resp_small)), size = smp_size)

train <- voter_hist_districts_resp_small[train_ind, ]
test <- voter_hist_districts_resp_small[-train_ind, ]

# WHEN WE DO K FOLD AND HAVE K SPLIT
# cat_col is what we want even distributions of
# parts <- partition(AllPreprocessed_wf_hrv_df, p = 0.2,  cat_col = 'Person')
# test_set <- parts[parts$.partitions == 1,]
# train_set <- parts[parts$.partitions == 2,]
# train_set <- fold(train_set, k = 5, cat_col = 'Person')
# train_set <- train_set %>% arrange(.folds)
```


# sample JAGS code (for structure)

```{r, eval=F}
# glmer(vote_or_no ~ some variables here +(1|county_desc), family = "binomial")

# random intercept: county_desc 
# main effect: median_household_income, gender_code, race_code, ethnic_code, birth_age, party_cd

# NEED TO USE MODEL.MATRIX or some other code to make data into design matrix (expand dummies and deal with interactions and stuff)

formula = vote_or_not ~  med_household_income+gender_code + race_code + ethnic_code + birth_age + party_cd + gender_code*party_cd
X = model.matrix(formula, data = train)

#saveRDS(X, "model_matrix_all_demographics_gpartyinter.rds")

x_inc = X[,"med_household_income"]
x_genderM = X[, "gender_codeM"]
x_genderU = X[, "gender_codeU"]
x_raceB = X[, "race_codeB"]
x_raceI = X[, "race_codeI"]
x_raceM = X[, "race_codeM"]
x_raceO = X[, "race_codeO"]
x_raceU = X[, "race_codeU"]
x_raceW = X[, "race_codeW"]



# mapping between name county aka Alamance and like county #1 (index in a array)
no_unique_counties = n_distinct(train$county_desc)
alphabetized_counties = sort(unique(train$county_desc))  

# nx1
county = match(train$county_desc, alphabetized_counties)
```

```{r}
# THIS IS SAMPLE STRUCTURE CODE FROM GELMAN AND HILL
# X[i, ] %*% beta

#xtest = X[, "med_household_income"]



model1 <- function() {
  # fixed effects 
  for (i in 1:n) {
    y[i] ~ dbin(theta[i], 1)
    theta[i] <- ilogit(a[county[i]] + b1*x_inc[i] + b2*x_genderM[i] + b3*x_genderU[i] + b4*x_raceB[i] + b5*x_raceI[i] + b6*x_raceM[i] +b7*x_raceO[i] +b8*x_raceU[i] +b9*x_raceW[i]
                        
                      #   b1*X[i, "med_household_income"] + b2*X[i, "gender_codeM"] + b3*X[i, "gender_codeU"] + b4*X[i, "race_codeB"] + b5*X[i, "race_codeI"] + b6*X[i, "race_codeM"]
                      # + b7*X[i, "race_codeO"] + b8*X[i,"race_codeU"] + b9*X[i, "race_codeW"] 
                      # + b10*X[i, "birth_age"] + b11*X[i, "party_cdGRE"] + b12*X[i, "party_cdLIB"] + b13*X[i, "party_cdREP"] + b14*X[i, "party_cdUNA"]
                      )
    

  }
  
  b1 ~ dnorm (0, .0001) 
  b2 ~ dnorm (0, .0001) 
  b3 ~ dnorm (0, .0001) 
  b4 ~ dnorm (0, .0001) 
  b5 ~ dnorm (0, .0001) 
  b6 ~ dnorm (0, .0001) 
  b7 ~ dnorm (0, .0001) 
  b8 ~ dnorm (0, .0001) 
  b9 ~ dnorm (0, .0001) 
  b10 ~ dnorm (0, .0001) 
  b11 ~ dnorm (0, .0001) 
  b12 ~ dnorm (0, .0001) 
  b13 ~ dnorm (0, .0001) 
  b14 ~ dnorm (0, .0001) 
  
  # random effects
  for (j in 1:J){
    a[j] ~ dnorm(mu.a, tau.a) 
  }
  
  mu.a ~ dnorm (0, .0001) 
  tau.a <- pow(sigma.a, -2) 
  sigma.a ~ dunif (0, 100)
}
```

```{r}
n = nrow(train)
y = train$vote_or_not

data_build_model = list(n=n, county = county, x_inc = x_inc, x_genderM = x_genderM, x_genderU = x_genderU, x_raceB = x_raceB, x_raceI = x_raceI, x_raceM = x_raceM, x_raceO = x_raceO, x_raceW = x_raceW, x_raceU = x_raceU, J = no_unique_counties, y=y)
params_to_output = c("a", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "theta", "y", "mu.a", "tau.a", "sigma.a")
model_output <- jags(data = data_build_model,
                     parameters.to.save = params_to_output,
                     n.iter = 10000,
                     n.chains = 2,
                     model.file = model1)
#lapply(1:9, function(x) {paste0("b",x)})
model_output
```


<!-- # ```{r} -->
<!-- # library(mice) -->
<!-- # tempData <- mice(voter_hist_districts, m=5, maxit=10, meth='pmm', seed=500) -->
<!-- # ``` -->

<!-- # ```{r} -->
<!-- # completedData1 <- complete(tempData,1) -->
<!-- # saveRDS(completedData1, "imp1_filtered_ncvoterhis.rds") -->
<!-- #  -->
<!-- # completedData2 <- complete(tempData,2) -->
<!-- # saveRDS(completedData2, "imp2_filtered_ncvoterhis.rds") -->
<!-- #  -->
<!-- # completedData3 <- complete(tempData,3) -->
<!-- # saveRDS(completedData3, "imp3_filtered_ncvoterhis.rds") -->
<!-- #  -->
<!-- # completedData4 <- complete(tempData,4) -->
<!-- # saveRDS(completedData4, "imp4_filtered_ncvoterhis.rds") -->
<!-- #  -->
<!-- # completedData5 <- complete(tempData,5) -->
<!-- # saveRDS(completedData5, "imp5_filtered_ncvoterhis.rds") -->
<!-- # ``` -->
