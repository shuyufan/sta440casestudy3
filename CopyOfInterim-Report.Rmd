---
title: "Interim Report: Who Votes in NC?"
author: "Alexander Bendeck, Lynn Fan, Cathy Lee, Alice Liao, Justina Zou"
date: "24 October 2020"
fontsize: 11pt
geometry: "left=1.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm"
output: 
  pdf_document: 
  latex_engine: xelatex
  fig_width: 2
  fig_height: 1
header-includes:
- \usepackage{booktabs}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pkgtest, echo=FALSE}
# source: https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages
pkgTest <- function(x)
  {
    if (!require(x,character.only = TRUE))
    {
      install.packages(x,repos = "http://cran.r-project.org",dep=TRUE)
        if(!require(x,character.only = TRUE)) stop("Package not found")
    }
  }
```

```{r check package,include=FALSE}
pkgTest("gtable") 
pkgTest("ggplot2") 
pkgTest("gridExtra") 
pkgTest("xtable") 
pkgTest("coda") 
pkgTest("dplyr")
pkgTest("reshape2")
pkgTest("readr")
pkgTest("grid")
pkgTest("bayesplot")
pkgTest("knitr")
pkgTest("tidyverse")
pkgTest("stringr")
pkgTest("stringi")
pkgTest("ggplotify")
pkgTest("tidybayes") # easy residuals
```

```{r packages, include=FALSE, message = F}
library(gtable)
library(ggplot2)
library(gridExtra)
# library(rjags)
# library(R2jags)
library(grid)
library(xtable)
library(coda)
library(bayesplot)
library(rstanarm)
library(dplyr)
library(reshape2)
library(knitr)
library(tidyverse)
library(stringr)
library(stringi)
library(ggplotify)
library(brms)
library(tidybayes) # easy residuals
#library(xtable)
```

# Introduction

The United States is getting closer to the 2020 Congressional Elections on November 3, 2020. With the current polarizing political landscape, the congressional election outcomes are significant to determine the next stage of this country. As it becomes critical for statisticians to help build forecasting models to predict the election outcomes, we need to first understand the patterns of voter turnout. Voting has special importance in democratic systems, but only about half of the eligible U.S. citizenry votes, and there are real political consequences when voters differ systematically from nonvoters (Uhlaner et al.). There has been abundant literature proving that variation in voter turnout will have electoral consequences (Hansford, et al.), in several ways. First of all, the media conventional wisdom is that "higher turnout benefits Democrats," although there has been mixed evidence about this theory (Weinschenk, 2019). Second, literature has proven certain demographic factors to statistically significantly benefit one party over the other, in both congressional elections and presidential races. For example, gender, race and party registration could help profile voting patterns for congressional elections (Uhlaner et al.). Election prediction models need to understand these patterns to predict the potential election outcomes.

Among all states, North Carolina has been a swing state in presidential and congressional elections for decades. In 2008, Obama won the state narrowly, but lost it narrowly after 4 years in 2012. Since 1996, the Republican statewide vote share in congressional elections has varied "from a low of 45% in 2008 to a high of 55% in 2014" (Perrin et al.). It makes North Carolina an interesting battleground in which voter demographic changes could potentially lead to significant impact on election outcomes and "an excellent site for those interested in partisan voting trends" (Perrin et al.). This report seeks to understand the voter turnout of North Carolina for 2020 NC Congressional Elections in order to predict who will vote in 2020.

# Data Description

We are using public data provided by the NC State Board of Elections, which can all be accessed directly at the link https://dl.ncsbe.gov/list.html. The database contains voter history information for elections within the past 10 years in the NC voter history files, and all legally available voter specific information in the NC voter registration files. The NC voter registration files contain point-in-time snapshot voter registration data. For privacy concerns, names, birth dates and drivers license are not included, but the two types of files could be matched by North Carolina identification (NCID) number. The NC voter registration files have 8,007,192 data points available. The database was last updated on September 9, 2020. While we understand that voters might register later than that as the voter registration deadline for North Carolina is October 9, 2020, we believe it is sufficient to represent the majority of NC potential voters.

From the NC voter history files, we only kept the voters that voted for the 2016 general election for our analysis. Among 8,522,310 data points showing voters that voted either for the 2016 general election or the 2018 midterm election, we kept the 4,768,188 voter records for 2016. Studies have shown that presidential elections help mobilize voters, so voter turnout in presidential election years are significantly higher. In recent elections, voter turnout during presidential election years is around 60%, and only about 40% during midterm elections (FairVote.org). For North Carolina, voter turnout data in 2018 is also inappropriate to use because neither of North Carolina’s U.S. senators nor the governor was up for reelection, further demotivating voters (Perrin et al.). From the NC voter registration files, we filtered demographic factors that are supported by existing literature to be significant in understanding voting patterns, including gender, race, party registration, and age (Kim et al.). We also have their county and congressional district information available. 

Additionally, we found relevant literature proving the relationship between voter turnout and wage (Charles et al.), so we added county-level median household income data from Economic Research Service under United States Department of Agriculture to our data set for analysis (https://www.ers.usda.gov/data-products/county-level-data-sets).

## Data Munging
After binding NC voter history files and NC voter registration files by NCID and binding NC median household income by county, we started to process data for analysis. First of all, we identified those 4,389 data points older than 116 years old and removed them as the oldest person in NC is 116 years old and anyone older should be wrong data points. Many data points are also missing congressional district information. We imputed the missing districts by matching the voter's registered county with congressional district. We removed the 4\% of voters who reside in counties that span across more than one congressional district. Because NC voter registration files show the voter registration data in 2020 while we are looking into voter turnout in 2016, it is important to treat those voters who were not eligible to vote in 2016. We subtract all voters' age by 4 years old to get the age information back in 2016, and then filtered out those 460,847 voters younger than 18 as they were unable to vote. We understand that doing so might introduce potential bias to the data set as the population 18-22 years old in 2020 might have different voting preferences than those 18-22 years old in 2016, but we believe the similarity of elections in 2016 and 2020 makes them comparable. Our **numerator** in voter turnout analysis is those who voted for the 2016 general election stored in NC voter history files, and our **denominator** is those registered voters in the NC voter registration files that were also eligible to vote back in 2016. The resulting binded data set has 7,229,595 rows.

After reading relevant literature in voter turnout analysis, we discovered that many papers used grouping to improve the estimation of the effects of individual and geographic predictors (Park, et al.). By aggregating demographics, researchers are also able to study collective political participation across groups, especially those who have been historically underrepresented (Uhlaner, et al.). Because we have eight million data points available, running models in a one-line-per-voter data set will also be very computationally expensive, and grouping can help us improve modeling efficiency. We instead decided to group data points by gender, race, party registration, county median income, and age, so that we can run models for the data set in a collapsed format. In the combined data set, there are party registrations for all parties, including the Libertarian Party and the Green Party. Because we are interested primarily only in the Republican Party and the Democratic Party and there are concerning class imbalance issues as the two parties take up the majority of registered voter population, we binded other parties as the third category `Other` for party. Similarly, because of class imbalance, we binded the races other than White and African Americans as `Other` for race as well. For those missing gender information, we binded them with `Unspecified`.

We divided (1) median county household income into four levels by the 25th, 50th, and 75th quantiles; (2) age into four levels for 18-29, 30-44, 45-59, and older than 60 years old, as it is a common way to analyze voter ages (McDonald, 2020); (3) gender into three categories, Female, Male and Other, and (4) race into three categories, Black, White, and Other. The final grouped data set has 432 subgroups (and therefore 432 rows). 

# EDA

```{r import-data, include = F}
voter_hist_districts_resp = readRDS("filtered_ncvoterhis_resp.rds")
```

```{r age-median_inc, include = F}
q25 = quantile(voter_hist_districts_resp$med_household_income, 0.25)
q50 = quantile(voter_hist_districts_resp$med_household_income, 0.50)
q75 = quantile(voter_hist_districts_resp$med_household_income, 0.75)

# first we need to bin age
voter_hist_districts_resp = voter_hist_districts_resp %>%
  mutate(age_2016 = birth_age - 4) %>%
  filter(!(age_2016 < 18)) %>%
  mutate(age_binned = case_when(
    age_2016 <= 29 ~ "18-29",
    age_2016 >= 30 & age_2016 <= 44 ~ "30-44",
    age_2016 >= 45 & age_2016 <= 59 ~ "45-59",
    age_2016 >= 60 ~ "60+"
  )) %>%
  mutate(med_inc_binned = case_when(
    med_household_income <=q25 ~ paste("<", q25),
    med_household_income > q25 & med_household_income <= q50 ~ paste(q25, "-", q50),
    med_household_income > q50 & med_household_income <= q75 ~ paste(q50, "-", q75),
    med_household_income > q75 ~ paste(">", q75)
  ))

voter_hist_districts_resp$med_inc_binned = factor(voter_hist_districts_resp$med_inc_binned, levels = c("< 46864", "46864 - 52798", "52798 - 64509", "> 64509"))

voter_hist_districts_resp$party_cd = factor(voter_hist_districts_resp$party_cd,
                                            levels = c("DEM", "REP", "Other"))

voter_grouped = voter_hist_districts_resp %>%
  group_by(age_binned, gender_code, party_cd, race_code, med_inc_binned) %>%
  summarise(n = n(), votes = sum(vote_or_not))

voter_grouped %>%
  arrange(., n)
```

```{r make-smaller, include = F}
#saved data with binned age, binned income
voter_hist_districts_resp  = voter_hist_districts_resp  %>%
  dplyr::select(-pct_description)
# saveRDS(voter_hist_districts_resp, "filtered_ncvoterhis_resp_binned.rds")

```

```{r EDA prep, include=F}
voter_grouped$voterpercent <- voter_grouped$votes / voter_grouped$n
```

```{r make cong dist}
voter_cong = voter_hist_districts_resp %>%
  group_by(age_binned, gender_code, party_cd, race_code, med_inc_binned, cong_dist_abbrv) %>%
  summarise(n = n(), votes = sum(vote_or_not))

voter_cong %>%
  arrange(., n)

voter_cong$voterpercent <- voter_cong$votes / voter_cong$n
```

```{r EDA cong, echo=F}
ggplot(voter_cong, aes(x = cong_dist_abbrv, y = voterpercent)) + geom_boxplot(aes(fill = party_cd)) + labs(y="Turnout Percentage", x = "Congressional District", title = "Voter Turnout for Different Congressional Districts", fill = "Party") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))
```

```{r EDA, echo=F, fig.width=8,fig.height=4, fig.align='center', fig.cap="Grouped Feature Variable Exploration"}
binned_race_party <- ggplot(voter_grouped, aes(x = race_code, y = voterpercent)) + geom_boxplot(aes(fill = party_cd)) + labs(y="Turnout Percentage", x = "Race", title = "Voter Turnout for Different \n Party Affliation and Race", fill = "Party") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))
binned_gender_party <- ggplot(voter_grouped, aes(x = gender_code, y = voterpercent)) + geom_boxplot(aes(fill = party_cd)) + labs(y="Turnout Percentage", x = "Gender", title = "Voter Turnout for Different \n Party Affliation and Gender", fill = "Party") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))
binned_age_gender <- ggplot(voter_grouped, aes(x = age_binned, y = voterpercent)) + geom_boxplot(aes(fill = gender_code)) + labs(y="Turnout Percentage", x = "Age", title = "Voter Turnout for Different Age and Gender", fill = "Gender") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))
binned_age_party <- ggplot(voter_grouped, aes(x = party_cd, y = voterpercent)) + geom_boxplot(aes(fill = age_binned)) + labs(y="Turnout Percentage", x = "Registered Party", title = "Voter Turnout for Different \n Party Affliation and Age", fill = "Age") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))

grid.arrange(grobs = list(binned_race_party, binned_gender_party, binned_age_gender, binned_age_party), ncol = 2)
```

After cleaning up data set and grouping demographic factors for analysis, Figure 1 aims to explore the the differences in voter turnout across different levels of party affiliation, gender, and age range. The upper left plot shows that white registered voters, on average, are more likely to vote than black registered voters, but black voters registered as Democrats have a comparable voter turnout as white voters. In the upper right plot, female registered voters are more likely to vote than male voters. The lower left plot shows that registered voters in the age range of 18-29 are the least likely to vote, which is consistent with existing literature (Kim et al.). Similar to the upper right plot, female voters have a higher voter turnout than male voters in all age groups displayed. The lower right plot shows a higher voter turnout among voters registered to be Democrats than those Republicans. In the Appendix, exploratory data analysis for county median household income and ungrouped demographic variables are shown in the additional EDA section. After comparing the plots, we conclude that grouping accurately retains the differences of voter turnout across different levels of these predictors, and decide to continue using grouped data for the modeling process.

# Method

We will take a Bayesian approach to not only predict if a voter with a certain profile would vote, but also understand quantitatively how the geographic and demographic information of a registered voter is associated with his or her likelihood of actually casting a ballot. Motivated by Y. Ghitza and A. Gelman’s idea of grouping (2013), we divide the population into mutually exclusive categories according to their demographic and geographic characteristics and fit a Bayesian model with group-level predictors as well as their interactions. We will then be able to get average estimates for each of the subgroups from the posterior distributions. Bayesian viewpoint is an intuitive way of incorporating data to update the estimates and this method allows us to quantify the uncertainty about the model. 

From Exploratory Data Analysis and literature, we identify voters' income (binned), gender, race, age (binned) and party affiliation as potentially useful predictors in predicting voter turnout. Furthermore, literature suggests possible interactions between some variables. Pew Research Center highlighted that historically party identification differs widely by gender (2020) and age (2016). J. Misra (2019) found while younger women voted at higher rates than younger men, women aged 65 and older voted at lower rates than men in the same age range. Walker et al (2019) found there are different effects across race and party subgroups on turnout especially in North Carolina due to its status as a swing state. 

We decided to use a fixed-effect logistic regression model. Since we are analyzing whether or not an individual votes, the range that the response variable can take is between 0 and 1; therefore, logistic regression using grouped summary data is the most reasonable model. Coefficients and confidence intervals will help us answer the research question on potential associations of predictor variables. We propose a model with the following equation: 

$$
\begin{aligned}
Vote_i \sim Binomial(n_i, \pi_i) \\
logit(\pi_i) = \alpha_0 + \Sigma_{s \in S}\beta_{j}*I(Income_i = Income \ Category_s) + \Sigma_{g \in G}\beta_g*I(Gender_i = Gender \ Category_g) +\\
\Sigma_{r \in R}\beta_r*I(Race_i = Race \ Category_r) + \Sigma_{a \in A}\beta_a*I(Age_i = Age \ Category_a) +\\
\Sigma_{p \in P}\beta_p*I(Party_i = Party \ Category_p) + \\
\Sigma_{g \in G, p \in P}\beta_{gp}*I(Gender_i = Gender \ Category_g)I(Party_i = Party \ Category_p) + \\
\Sigma_{r \in R, p \in P}\beta_{rp}*I(Race_i = Race \ Category_r)I(Party_i = Party \ Category_p) + \\
\Sigma_{g \in G, a \in A}\beta_{ga}*I(Gender_i = Gender \ Category_g)I(Age_i = Age \ Category_a) + \\
\Sigma_{p \in P, a \in A}\beta_{pa}*I(Party_i = Party \ Category_p)I(Age_i = Age \ Category_a) 
\end{aligned}
$$

where:
$$
\begin{aligned}
S = \{Median \ Income \ \$46864-\$52798,  \ Median \ Income \ \$52798-\$64509, \ Median \ Income > \$64509\}\\
G = \{Male, Unspecified\} \\
R = \{Black, Other\} \\
A = \{Age \ 30-44, \ Age \ 45-59, \ Age \ 60+\} \\
P = \{Republican, \ Other\}
\end{aligned}
$$

Where $\pi_i$ is the probability that subgroup $i$ votes. $Vote_i$ is the number of people in the $i$th subgroup that voted in the 2016 election. The baseline is `Median Income < $46864` for income, `Female` for gender, `White` for race, `18-29` for age, and `Democrat` for party affiliation.

Due to the lack of strong prior knowledge, we will use `brm` function's default priors: flat prior for all the $\beta$ coefficients and a Student t distribution for $\alpha$  (i.e. $\alpha \sim Student_3(0,2.5)$).

In a later section, we will compare this Bayesian model with two additional models: one is a frequentist logistic regression model with the same predictors and interactions and the other is a similar Bayesian model with an additional random effect at the congressional district level. In this way, we hope to assess if the Bayesian framework is superior to a frequentist approach when predicting voter turnout and if there is any salient unexplained variation within each congressional district. 

```{r run-brms-model, cache = T, include = F, warning = F, message = F}
binary_model <-
  brm(data = voter_grouped, family = binomial,
      votes | trials(n) ~ 1 + med_inc_binned + gender_code + race_code + age_binned + party_cd + gender_code:party_cd + race_code:party_cd + gender_code:age_binned + party_cd:age_binned,
      iter = 2500, warmup = 500, cores = 2, chains = 2,
      seed = 10)
#summary(binary_model)
#saveRDS(binary_model, "grouped_model_no_randeff_whole_dataset.rds")
```

# Results and Interpretations

```{r, coeff-table, include = F}
coef_table1 = round(fixef(cong_dist_rand_eff),2)[1:17,]
colnames(coef_table1) = c("Est", "SE", "2.5% Q", "97.5% Q")
rownames(coef_table1) = c("Intercept", "46.9k-52.8k", "52.8k-64.5k", ">64.6k", "Male", "Unspecified", "Black", "Other Race", "30-44", "45-59", "60+", "Republican", "Other Party","Male:Rep", "Unspec:Rep", "Male:Other Pty", "Unspec:Other Pty") 

coef_table2 = round(fixef(cong_dist_rand_eff),2)[18:33,]
colnames(coef_table2) = c("Est", "SE", "2.5% Q", "97.5% Q")
rownames(coef_table2) = c("Black:Rep", "Other Race:Rep",  "Black:Other Pty", "Other Race:Other Pty",  "Male:30-44", "Unspec:30-44", "Male:45-59", "Unspec:45-59", "Male:60+", "Unspec:60+", "30-44:Rep", "45-59:Rep", "60+:Rep", "30-44:Other Pty", "45-59:Other Pty", "60+:Other Pty")
```

```{r sample, echo=FALSE, results='asis'}
t1 <- kable(coef_table1, format = "latex", booktabs = TRUE)
t2 <- kable(coef_table2, format = "latex", booktabs = TRUE)

cat(c("\\begin{table}[!htb]
    \\begin{minipage}{.5\\linewidth}
      \\caption{Coefficient Table Part 1}
      \\centering",
        t1,
    "\\end{minipage}%
    \\begin{minipage}{.5\\linewidth}
      \\centering
        \\caption{Coefficient Table Part 2}",
        t2,
    "\\end{minipage} 
\\end{table}"
))  
```

Table 1 and Table 2 show that each coefficient has small standard errors (no indication of identifiability issues). In addition, we see that all variables except for the interaction between unspecified gender and third/unregistered party have credible intervals that do not contain 0, indicating significance in determining who votes. We are not particularly concerned about the this interaction not being significant since the interaction between gender and party for the other levels are significant, so we still include this interaction in the model. We can interpret the intercept and coefficients as follows: 

- For a white, female Democrat aged 18-29 whose county median household income is in the lowest category (< $\$46.9k$), the odds of voting is `r round(exp(0),2)` with a 95% CI of (`r round(exp(-0.1),2)`, `r round(exp(0),2)`). 
- For a white, female Democrat aged 18-29 whose county median household income is in the second quartile ($\$46.9k-\$52.8k$), the odds of voting increases by a multiplicative factor `r round(exp(0.1),2)` with a 95% CI of (`r round(exp(0.09),2)`, `r round(exp(0.10),2)`) compared to the first quartile (< $\$46.9k$). 
- Holding county median household income (< $\$46.9k$), race (White), party (Democrat), and age (18-29) at baseline, the odds of voting among men is `r round(exp(-0.43),2)` times that among women with a 95% CI of (`r round(exp(-0.44),2)`, `r round(exp(-0.42),2)`). We can also note that, holding county median household income and age at baseline, the odds of voting among black Republican men is `r round(exp(-0.43+0.18-0.98),2)` times that among black Republican women. 

<!-- with a 95% CI of (`r round(exp(-0.44+0.17-1),2)`, `r round(exp(-0.42+0.19-0.96),2)`). *not sure if we can just sum up the CI?*  -->

- For white, female Democrat voters with county median household income less than $\$46.9k$, the odds of voting among those aged 30-44 would be `r round(exp(0.62),2)` times higher than among those aged 18-29 with 95% CI of (`r round(exp(0.61),2)`, `r round(exp(0.63),2)`). In fact, if we hold all other variables at baseline, the odds of voting is the lowest in the lowest age group. The odds of voting among older (aged 60+) Republican white male voters with median income less than $\$46.9k$ is `r round(exp(0.94+0.19-0.43+0.18+0.25-0.06),2)` times more likely than the odds of voting among voters with all baseline demographic characteristics.

<!-- # ```{r plot-to-interpret-main-test, eval = F, message = F, warning = F, fig.width = 8, fig.height = 4, fig.cap="Marginal Effect of Median Household Income"} -->
<!-- # p1 = plot(conditional_effects(binary_model, effects = "med_inc_binned"), plot=FALSE)[[1]] -->
<!-- # # p1$labels$fill <- "Median Household Income" -->
<!-- # # p1$labels$colour <- “Horizontal\ndifference” -->
<!-- # p1 <- p1 + labs(x = "Median Household Income", y = "Fitted Probabilities") -->
<!-- # p1 <- p1 + -->
<!-- # theme(axis.text=element_text(size=8), axis.title=element_text(size=14))#, #legend.text=element_text(size=12), legend.title = element_text(size = 12)) -->
<!-- # print(p1) -->
<!-- # # plot(y~x, xaxt="none", main="Turn off x-axis") -->
<!-- # # prob not x or xlab -->
<!-- # ``` -->

<!-- From \emph{Figure 2}, we see that the expected probability of voting is generaly greater that 50% for all median household income levels, but tends to increase as median household income increases, holding all other attributes constant (age, gender, race, party). -->

```{r plot-to-interpret-interactions1, include = F, message = F, warning = F, fig.width = 8, fig.height = 4, fig.cap="\\label{interp1} Marginal Effect of Race by Party and Gender"}
conditions <- data.frame(gender_code = as.character(c("F", "M", "U")))
p2 = plot(conditional_effects(cong_dist_rand_eff, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "F", "2" = "M", "3" = "U"))), plot=FALSE)[[1]]
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"

p2 <- p2 + labs(x = "Race", y = "Fitted Probabilities")
p2 <- p2 +
theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
#print(p2)
```

```{r plot-to-interpret-interactions2, include = F, message = F, warning = F, fig.width = 8, fig.height=4, fig.cap = "\\label{interp2} Marginal Effect of Party by Age and Race"}
conditions <- data.frame(race_code = as.character(c("White", "Black", "Other")))
p3 = plot(conditional_effects(cong_dist_rand_eff, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "White", "2" = "Black", "3" = "Other"))), plot=FALSE)[[1]]
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"

p3 <- p3 + labs(x = "Party", y = "Fitted Probabilities")
p3 <- p3 +
theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
# print(p3)
```

```{r, echo = F, message = F, warning = F, fig.width = 10, fig.height=4, fig.cap = "\\label{bothinterp} Marginal Effect of Party by Age and Race"}
grid.arrange(p2,p3, nrow = 1)
```

We can interpret each point in the left plot of Figure \ref{bothinterp} as follows: holding county median household income at baseline (less than $\$46,864$) and age at baseline (ages 18-29), the y-axis value is the expected probability that a person of a particular race (x-axis), party (color), and gender (facet) votes. For example, the expected probability that a black, male, Democrat votes is 0.4, whereas the expected probability that a black, male, Republican votes is approximately 0.28. We can also see that women, regardless of race and party, are expected to be more likely to vote than men. The plot on the right in Figure \ref{bothinterp} shows that, holding county median household income at baseline (less than $\$46,864$) and gender at baseline (female), the expected probability of voting for white Democrats within each age group is less than that for white Republicans. However, the expected probability of voting among black Democrats within each age group is higher than that among black Republicans.

# Model Validation

```{r k-fold-diff-ks, echo = F, cache = T, warning = F, message = F, include = F, eval = F}
# Validation & diagnostics start below ------------------------------
# 3-fold & 5-fold CV
set.seed(123)
#k3 <- kfold(binary_model, K = 3, save_fits = TRUE)
#k5 <- kfold(binary_model, K = 5, save_fits = TRUE)
k10 <- kfold(binary_model, K = 10, save_fits = TRUE)

## Slot yrep contains the matrix of predicted responses, 
## with rows being posterior draws and columns being observations
## (from documentation) 
#k3_pred <- kfold_predict(k3, method = "fitted")
#k5_pred <- kfold_predict(k5, method = "fitted")
k10_pred <- kfold_predict(k10, method = "fitted")
```

```{r rmse, include = F, eval = F}
# define a loss function
# (from documentation kfold_predict)
rmse <- function(y, yrep) {
  yrep_mean <- colMeans(yrep)
  sqrt(mean((yrep_mean - y)^2))
}

# Print RMSE results
cat('RMSE with 3-fold CV:', rmse(y = k3_pred$y, yrep = k3_pred$yrep), '\n')
cat('RMSE with 5-fold CV:', rmse(y = k5_pred$y, yrep = k5_pred$yrep), '\n')
cat('RMSE with 10-fold CV:', rmse(y = k10_pred$y, yrep = k10_pred$yrep), '\n')
```

```{r posterior-pred-checks, echo = F, fig.width = 8, fig.height = 4, warning = F, message = F, fig.cap = "\\label{ppc} Posterior Predictive Checks Plots"}
# PPC
ppc = pp_check(cong_dist_rand_eff) + 
  xlab("Number Voted") + 
  ylab("Density") + 
  yaxis_ticks() + 
  yaxis_text()

d <-
  voter_grouped %>% 
  ungroup() %>% 
  mutate(case = factor(1:nrow(voter_grouped))) # all the different cases (e.g. B race AND R party AND <29 age, etc. essentially each row)

p <-
  predict(cong_dist_rand_eff) %>%
  as_tibble() %>%
  bind_cols(d)

dot = ggplot(data = d, aes(x = case, y = votes / n)) +
  geom_pointrange(data = p,
                  aes(y    = Estimate / n,
                      ymin = Q2.5     / n ,
                      ymax = Q97.5    / n),
                  color = '#2F4F4F',
                  shape = 1, alpha = 1/3) + 
  geom_point(data=d, aes(x=case, y=votes/n)) +
  theme(axis.text.x=element_blank()) +
  labs(y = "Voter Turnout", x = "Groups")

grid.arrange(ppc, dot, ncol = 2)
# # True dots colored by whether it was within the quantile or not
# temp <- cbind(d, p[,1:4])
# temp$within <- ((temp$votes)/temp$n >= (temp$Q2.5)/temp$n) & 
#   ((temp$votes)/temp$n <=( temp$Q97.5)/temp$n)
# ggplot(data = temp, aes(x = case, y = votes / n)) +
#   geom_pointrange(data = temp,
#                   aes(y    = Estimate / n,
#                       ymin = Q2.5     / n ,
#                       ymax = Q97.5    / n),
#                   color = '#2F4F4F',
#                   shape = 1, alpha = 1/3) + 
#   geom_point(data=temp, aes(x=case, y=votes/n, color=within))
```

Figure \ref{ppc} displays the posterior predictive checks for our model. On the left, the dark black line is the observed distribution and the light blue line is the simulated distribution. On the right, the black dots are the actual voter turnout for each subgroup, and the grey points are the predicted turnout with 95% credible intervals. The plots show that our simulated distribution is similar to the observed distribution. Our simulations also produce few outliers. It appears that most of the true values are covered by the 95% confidence intervals of the predicted values, indicating model fit. *TODO: discuss the 0 100 as limitations of the dataset*

```{r resids, echo = F, fig.width = 8, fig.height = 4, fig.cap = "\\label{resplot} Residual Plot"}
# Residuals

fitted_randeff = predict(cong_dist_rand_eff, voter_grouped, type = "fitted")
resids = fitted_randeff[,1] - voter_grouped$votes

std.resids = resids/sqrt(var(resids))

voter_grouped$std.resids = std.resids

voter_grouped %>%
  add_residual_draws(cong_dist_rand_eff) %>%
  #ggplot(aes(x = resids, y = std.resids)) +
  #geom_point() +
  stat_pointinterval() + 
  geom_hline(yintercept = 0, color="red") + 
  labs(x = "Group", y = "Standardized Residuals")
```

Most of the standardized residuals (shown in Figure 4) are within $\pm$ 2, but some points have somewhat larger values. This means that for the majority of the groups, the model predicts fairly well. 

```{r internal-2016-rmse} 
fitted_main <- predict(binary_model, method="fitted")
rmse <- function(y, yrep) {
  #yrep_mean <- colMeans(yrep)
  sqrt(mean((yrep - y)^2))
}
#cat(fname, '\n')
cat('RMSE main effects model:', rmse(
  y = binary_model$data$votes, yrep = fitted_main[,1]), '\n')

fitted_randeff <- predict(cong_dist_rand_eff, method="fitted")

#cat(fname, '\n')
cat('RMSE random effects model:', rmse(
  y = cong_dist_rand_eff$data$votes, yrep = fitted_randeff[,1]), '\n')
```

```{r external-validation, fig.width = 8, fig.height = 4, echo = F, message = F, warning = F, eval = F}
grouped_voters_2012 = readRDS("grouped_voter_data_2012.rds")

grouped_voters_2012 = grouped_voters_2012 %>%
  mutate(med_inc_binned = case_when(
    med_inc_binned == "46864 _ 52798" ~ '46864 - 52798',
    med_inc_binned == "52798 _ 64509" ~ '52798 - 64509',
    TRUE ~ med_inc_binned
  ))

extern_est = predict(binary_model, grouped_voters_2012, type = "response")[,1]
extern_rmse = sqrt(mean((extern_est - grouped_voters_2012$votes)^2))
```

```{r extern-validation}

voters_2012 = readRDS("filtered_ncvoterhis_resp_binned_2012.rds")

grouped_voters_2012 = voters_2012 %>%
  group_by(age_binned, gender_code, party_cd, race_code, med_inc_binned) %>%
  summarise(n = n(), votes = sum(vote_or_not))

grouped_voters_2012 %>%
  arrange(., n)

grouped_voters_2012 = grouped_voters_2012 %>%
  mutate(med_inc_binned = case_when(
    med_inc_binned == "46864 _ 52798" ~ '46864 - 52798',
    med_inc_binned == "52798 _ 64509" ~ '52798 - 64509',
    TRUE ~ med_inc_binned
  ))

extern_est_main_model = predict(binary_model, grouped_voters_2012, type = "response")[,1]
extern_rmse_main_model = sqrt(mean((extern_est_main_model - grouped_voters_2012$votes)^2))

grouped_voters_2012 = voters_2012 %>%
  group_by(age_binned, gender_code, party_cd, race_code, med_inc_binned, cong_dist_abbrv) %>%
  summarise(n = n(), votes = sum(vote_or_not))

grouped_voters_2012 = grouped_voters_2012 %>%
  mutate(med_inc_binned = case_when(
    med_inc_binned == "46864 - 52798" ~ '46864 _ 52798',
    med_inc_binned == "52798 - 64509" ~ '52798 _ 64509',
    TRUE ~ med_inc_binned
  ))

# 2012 validation for randeff model
extern_est_randeff_model = predict(cong_dist_rand_eff, grouped_voters_2012, type = "response")[,1]
extern_rmse_randeff_model = sqrt(mean((extern_est_randeff_model - grouped_voters_2012$votes)^2))

# med_inc_binned52798_64509 (6 nonzero containing CI)
# gender_codeU (7 nonzero containing CI)
# race_codeBlack (5)
# race_codeOther (9)
# age_binned30M44 (7)
# age_binned45M59 (8)
# age_binned60P (9)
# party_cdOther (7)
# party_cdREP (8)
```

We conducted external validation on the 2012 dataset, cleaned the same way the 2016 dataset was cleaned. The RMSE for the 2012 dataset is `r round(extern_rmse,2)`, which is larger than the RMSE from internal validation for the 2016 dataset, `r round(rmse(y = k10_pred$y, yrep = k10_pred$yrep),2)`. This is to be expected because the candidates on the ballot between the two elections may mobilize different types of voters. For example, Hillary Clinton being on the ballot prompted many women to come out to vote, whereas Barack Obama in the 2012 election prompted many African Americans to vote (Weinschenk, et al). 

# Sensitivity Analysis

```{r warning=FALSE, echo = F}
binary_model_waic_obj = waic(binary_model)
binary_model_waic = binary_model_waic_obj$estimates[3,1]
#saveRDS(binary_model, "grouped_model_no_randeff_whole_dataset.rds")
```

```{r, include = F}
randeff_model = readRDS("randeff_sa_grouped_model_whole_data_output.rds")
#summary(randeff_model)
```

```{r warning=FALSE, echo = F}
randeff_model_waic_obj = waic(randeff_model)
randeff_model_aic = randeff_model_waic_obj$estimates[3,1]
#saveRDS(binary_model, "grouped_model_no_randeff_whole_dataset.rds")
```

As part of our sensitivity analysis, we fit a model with identical predictor variables to our main model but with different priors. Based on literature review, we chose normal priors for the main effects that aligned with expectations that older voters tend to vote more often (McDonald, 2020), men tend to vote less often than women (Igielnik, 2020), party-unaffiliated voters tend to vote less often (Killian, 2012), and wealth tends to correlate positively with voter turnout (Akee, 2019). For these main effects, we chose the normal priors to have means somewhere between 0.5 and 1, and we chose a variance of 3. For all other terms (including interactions and intercept), we chose normal priors with a mean of 0 and a variance of 3. Changing these priors had minimal effect on the resulting coefficients and confidence intervals (see model output in Appendix).

We also fit another model with random intercept and slopes with all of the predictors for congressional districts to capture possible variation between voters in different geographic parts of North Carolina. The coefficients for the main effects (included in the Appendix, along with group-level standard deviation) look largely the same compared to the main model, with the exception that the coefficients for income are slightly different in the two models. This is perhaps because some of the variations between different income groups can be attributed to differences between counties. We did not choose this model as our main model because it has a higher WAIC (`r format(round(cong_dist_rand_eff_aic, 2), scientific=F)`) compared to the main model (`r format(round(binary_model_waic, 2), scientific=F)`). In addition, the RMSE when predicting on 2012 data for the random effects model (`r rmse(cong_dist_rand_eff$data$votes, yrep = fitted)`) was worse than that for the main model. 


Finally, since all of the models discussed above were fit using a Bayesian framework via the \texttt{brms} package, we decided to fit a frequentist model for comparison. The model output (included in the Appendix) shows little difference from the results of our main Bayesian model.

# Conclusion and Limitations

We fit a Bayesian logistic regression model to model the binary outcome of whether or not a demographic subgroup, defined by their race, gender, party affiliation, age, and median county household income (such as white female Democrats between 30-44 years of age whose county median household income is greater than $64,509) votes. Based on results from literature review, we added interactions between gender and party, race and party, age and gender, and age and party. After model comparison, we did not include random effects in our model. Our MCMC diagnostics and model diagnostics do not indicate a lack of fit and show that our model coefficients converge well. 

All of the demographic variables, as well as the interactions, were significant except for the interaction between unspecified gender and the third/unspecified party category. From the plots of the marginal effects of the covariates, holding county median household income at the $< \$46,864$ category and holding age at the 18-29 level, we found that females have a higher expected probability of voting than male registered voters. For those with the same county median household income as above and are female, we note that among white voters, Republicans are more likely to vote than Democrats, while the opposite is true among black voters. We also found that for those whose county median household income falls in the highest category ($> \$64,509$), the expected probability of voting is larger relative to any other income category.

The biggest strength of this study is its focus on grouping data. Grouping data to analyze voting patterns makes results helpful for future analysis of the same demographic groups, and candidates can use this result to adjust their resource allocation during campaigns.  Another strength is the substantial amount of diagnostics, validation, and sensitivity analysis done to evaluate model fit and demonstrate the robustness of our final model.

Many limitations were already addressed previously. Others include the weaknesses of the data set, namely that the voting patterns in 2016 will not completely match that of 2020 even though Trump has been the Republican candidate for both races. This is because the Democratic candidate may mobilize voters differently and the political landscape has changed between 2016 and 2020 (Weinschenk et al.). Also, grouping prevents us from analyzing individual-level demographic variations and predictors not yet included in our analysis. As voter turnout is a very complicated subject and a lot of predictors might be relevant in shaping voting patterns, we might be oversimplifying the study with the number of predictors we have on the group level.

Finally, while demographic variables are key to explain election voter turnout, elections are complicated events and more facets of elections and diverse data sources, analyzed by different analyses, are necessary to understand voter turnout and election outcomes (Weinschenk et al.).

# Appendix

## References
1. Linzer, D. A. (2013). Dynamic Bayesian Forecasting of Presidential Elections in the States. Journal of the American Statistical Association, 108(501), 124-134. doi:10.1080/01621459.2012.737735
\newline
2. Hansford, T. G., &amp; Gomez, B. T. (2010). Estimating the Electoral Effects of Voter Turnout. American Political Science Review, 104(2), 268-288. doi:10.1017/s0003055410000109
\newline
3. 2020 Election. (2020, October 20). Retrieved October 20, 2020, from https://fivethirtyeight.com/politics/elections/
\newline
4. Park, D. K., Gelman, A., &amp; Bafumi, J. (2006). State-Level Opinions from National Surveys:. Public Opinion in State Politics, 209-228. doi:10.2307/j.ctvr33bdg.17
\newline
5. Mahler, V. A., Jesuit, D. K., &amp; Paradowski, P. R. (2013). Electoral Turnout and State Redistribution. Political Research Quarterly, 67(2), 361-373. doi:10.1177/1065912913509306
\newline
6. Uhlaner, C. J., &amp; Scola, B. (2015). Collective Representation as a Mobilizer. State Politics &amp; Policy Quarterly, 16(2), 227-263. doi:10.1177/1532440015603576
\newline
7. Godbout, J. (2012). Turnout and presidential coattails in congressional elections. Public Choice, 157(1-2), 333-356. doi:10.1007/s11127-012-9947-7
\newline
8. Kim, S. S., Alvarez, R. M., &amp; Ramirez, C. M. (2020). Who Voted in 2016? Using Fuzzy Forests to Understand Voter Turnout. doi:10.33774/apsa-2020-xzx29
\newline
9. Weinschenk, A. C. (2019) That’s Why the Lady Lost to the Trump: Demographics and the 2016 Presidential Election, Journal of Political Marketing, 18:1-2, 69-91, DOI: 10.1080/15377857.2018.1478657
\newline
10. Charles, K. K., &amp; Stephens, M. (2011). Employment, Wages and Voter Turnout. doi:10.3386/w17270
\newline
11. Hills, M. (2020, September 25). US election 2020: A really simple guide. Retrieved October 20, 2020, from https://www.bbc.com/news/election-us-2020-53785985
\newline
12. Railey, K. (2016). Federal Judges Let Stand North Carolina,'s New Congressional Map. The Hotline. https://link.gale.com/apps/doc/A498010836/ITOF?u=duke_perkins&sid=ITOF&xid=119d6ad9
\newline
13. Perrin, A. J., &amp; Ifatunji, M. A. (2020). Race, Immigration, and Support for Donald Trump: Evidence From the 2018 North Carolina Election. Sociological Forum, 35(S1), 941-953. doi:10.1111/socf.12600
\newline
14. Redistricting in North Carolina. (2020). Retrieved October 21, 2020, from https://ballotpedia.org/Redistricting_in_North_Carolina
\newline
15. Â§ 132-1. Public Records.
https://www.ncleg.gov/EnactedLegislation/Statutes/PDF/BySection/Chapter_132/GS_132-1.pdf
\newline
16. Â§ 163-82.10.  Official record of voter registration.
https://www.ncleg.gov/EnactedLegislation/Statutes/PDF/BySection/Chapter_163/GS_163-82.10.pdf
\newline
17. FairVote.org. (n.d.). Voter Turnout. Retrieved October 22, 2020, from https://www.fairvote.org/voter_turnout
\newline
18. McDonald, M. P. (2020). Voter Turnout Demographics. Retrieved October 23, 2020, from http://www.electproject.org/home/voter-turnout/demographics
\newline
19. Y. Ghitza, A. Gelman’s (2013). Deep interactions with MRP: Election Turnout and Voting Patterns Among Small Electoral Subgroups. American Journal of Political Science 57 762– 776.
\newline
20. Walker, H.L., Herron, M.C. & Smith, D.A. Early Voting Changes and Voter Turnout: North Carolina in the 2016 General Election. Polit Behav 41, 841–869 (2019). https://doi-org.proxy.lib.duke.edu/10.1007/s11109-018-9473-5 
\newline
21. Pew Research Center (2020). Men and women in the U.S. continue to differ in voter turnout rate, party identification. https://www.pewresearch.org/fact-tank/2020/08/18/men-and-women-in-the-u-s-continue-to-differ-in-voter-turnout-rate-party-identification/ 
\newline
22. Pew Research Center (2016). Party affiliation among voters: 1992-2016.
https://www.pewresearch.org/politics/2016/09/13/2-party-affiliation-among-voters-1992-2016/ 
\newline
23. J. Misra (2019). Voter Turnout Rates Among All Voting Age and Major Racial and Ethnic Groups Were Higher Than in 2014. https://www.pewresearch.org/fact-tank/2020/08/18/men-and-women-in-the-u-s-continue-to-differ-in-voter-turnout-rate-party-identification/
\newline
24. Killian, L. (2012). Five Myths About Independent Voters. Retrieved October 22, 2020, from https://www.washingtonpost.com/opinions/five-myths-about-independent-voters/2012/05/17/gIQAZmGyWU_story.html
\newline
25. Igielnik, R. (2020). Men and Women in the U.S. Continue to Differ in Voter Turnout Rate. Retrieved October 22, 2020, from https://www.pewresearch.org/fact-tank/2020/08/18/men-and-women-in-the-u-s-continue-to-differ-in-voter-turnout-rate-party-identification/
\newline
26. Akee, R. (2019). Voting and Income. Retrieved October 22, 2020, from https://econofact.org/voting-and-income

## Additional EDA

```{r, echo = F, fig.width = 8, fid.height = 4}
binned_income <- ggplot(voter_grouped, aes(x = med_inc_binned, y = voterpercent)) + geom_boxplot() + labs(aes(fill = party_cd), y="Turnout Percentage", x = "County Median Household Income", title = "Voter Turnout for Different \n Median Household Income and Party Affliation") +theme(plot.title = element_text(hjust = 0.5,size = 8),axis.title=element_text(size=8),legend.key.size = unit(0.5,"line"))
density_age_party <- ggplot(voter_hist_districts_resp, aes(birth_age,color=party_cd)) + labs(y="Density", x = "Age", title = "Marginal Density for Ages \n of Different Party Voters") + geom_density(alpha=.5)  +theme(plot.title = element_text(hjust = 0.5))
stacked_race_party <- ggplot(voter_hist_districts_resp, aes(race_code,fill=party_cd)) + labs(y="Density", x = "Age", title = "Race v. Party")+ geom_bar( position="fill", stat="count") + theme(plot.title = element_text(hjust = 0.5))
box_age_race <- ggplot(voter_hist_districts_resp, aes(x=race_code, y=birth_age)) + geom_boxplot() + labs(y="Age", x = "Race", title = "Age v. Races")  +theme(plot.title = element_text(hjust = 0.5)) 
# binned_income
# density_age_party
# stacked_race_party
# box_age_race
grid.arrange(binned_income,density_age_party,stacked_race_party,box_age_race, nrow = 2)
```

## Plots

```{r main-effects-plots, echo = F, fig.height = 5, fig.width = 8, message = F, warning = F}
main_effects = c("med_inc_binned", "gender_code", "race_code", "age_binned", "party_cd")

# as.grob does not work when run as part of the function for some reason
# plot_maineff = function(var) {
#   #as.grob(expression(
#     plot(conditional_effects(binary_model, effects = var))#))
# }

p1 = as.grob(plot(conditional_effects(binary_model, effects = main_effects[1]), plot=FALSE)[[1]] + labs(x = "County Median Household Income", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14)))
p2 = as.grob(plot(conditional_effects(binary_model, effects = main_effects[2]), plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14)))
p3 = as.grob(plot(conditional_effects(binary_model, effects = main_effects[3]), plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14)))
p4 = as.grob(plot(conditional_effects(binary_model, effects = main_effects[4]), plot=FALSE)[[1]] + labs(x = "Binned Age", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14)))
p5 = as.grob(plot(conditional_effects(binary_model, effects = main_effects[5]), plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14)))

grid.arrange(grobs = list(p1, p2, p3, p4, p5), ncol = 2)
```

```{r interactions-plot1, echo = F, fig.height = 5, fig.width = 10, message = F, warning = F}
conditions <- data.frame(gender_code = as.character(c("M", "F", "U")))
p1 <- plot(conditional_effects(binary_model, effects = "gender_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "F", "2" = "M", "3" = "U"))), plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p1$labels$fill <- "Party"
p1$labels$colour <- "Party"
p1 = as.grob(p1)

p2 <- plot(conditional_effects(binary_model, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "F", "2" = "M", "3" = "U"))), plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"
p2 = as.grob(p2)

p3 <- plot( conditional_effects(binary_model, effects = "gender_code:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "F", "2" = "M", "3" = "U"))), plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"
p3 = as.grob(p3)
     
p4 <- plot( conditional_effects(binary_model, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "F", "2" = "M", "3" = "U"))), plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p4$labels$fill <- "Binned Age"
p4$labels$colour <- "Binned Age"
p4 = as.grob(p4)
     
grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```

```{r, interactions-plot-2, echo = F, fig.height = 5, fig.width = 10, message = F, warning = F}
conditions <- data.frame(party_cd = as.character(c("DEM", "REP", "Other")))

p1 <- plot(conditional_effects(binary_model, effects = "gender_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "DEM", "2" = "REP", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p1$labels$fill <- "Party"
p1$labels$colour <- "Party"
p1 = as.grob(p1)
     
p2 <- plot(conditional_effects(binary_model, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "DEM", "2" = "REP", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"
p2 = as.grob(p2)
     
p3 <- plot( conditional_effects(binary_model, effects = "gender_code:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "DEM", "2" = "REP", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"
p3 = as.grob(p3)
     
p4 <- plot( conditional_effects(binary_model, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "DEM", "2" = "REP", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p4$labels$fill <- "Binned Age"
p4$labels$colour <- "Binned Age"
p4 = as.grob(p4)
     
grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```

```{r, interactions-plot-3, echo = F, fig.height = 5, fig.width = 10, message = F, warning = F}
conditions <- data.frame(race_code = as.character(c("White", "Black", "Other")))
p1 <- plot(conditional_effects(binary_model, effects = "gender_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "White", "2" = "Black", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p1$labels$fill <- "Party"
p1$labels$colour <- "Party"
p1 = as.grob(p1)

p2 <- plot(conditional_effects(binary_model, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "White", "2" = "Black", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"
p2 = as.grob(p2)
     
p3 <- plot( conditional_effects(binary_model, effects = "gender_code:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "White", "2" = "Black", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"
p3 = as.grob(p3)
     
p4 <- plot( conditional_effects(binary_model, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "White", "2" = "Black", "3" = "Other"))),
     plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p4$labels$fill <- "Binned Age"
p4$labels$colour <- "Binned Age"
p4 = as.grob(p4)
grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```

```{r, interactions-plot-4, echo = F, fig.height = 5, fig.width = 10, message = F, warning = F}
conditions <- data.frame(age_binned = as.character(c("18-29", "30-44", "45-59", "60+")))
p1 <- plot(conditional_effects(binary_model, effects = "gender_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "18-29", "2" = "30-44", "3" = "45-59", "4" ="60+")), ncol = 2),
     plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p1$labels$fill <- "Party"
p1$labels$colour <- "Party"
p1 = as.grob(p1)

p2 <- plot(conditional_effects(binary_model, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "18-29", "2" = "30-44", "3" = "45-59", "4" ="60+")), ncol = 2),
       plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"
p2 = as.grob(p2)

p3 <- plot( conditional_effects(binary_model, effects = "gender_code:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "18-29", "2" = "30-44", "3" = "45-59", "4" ="60+")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"
p3 = as.grob(p3)

p4 <- plot(conditional_effects(binary_model, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "18-29", "2" = "30-44", "3" = "45-59", "4" ="60+")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p4$labels$fill <- "Binned Age"
p4$labels$colour <- "Binned Age"
p4 = as.grob(p4)

grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```

```{r, interactions-plot-5, echo = F, fig.height = 5, fig.width = 10, message = F, warning = F}
conditions <- data.frame(med_inc_binned = as.character(c("< 46864", "46864 - 52798", "52798 - 64509", "> 64509")))
p1 <- plot(conditional_effects(binary_model, effects = "gender_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "< 46864", "2" = "46864 - 52798", "3" = "52798 - 64509", "4" ="> 64509")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p1$labels$fill <- "Party"
p1$labels$colour <- "Party"
p1 = as.grob(p1)

p2 <- plot(conditional_effects(binary_model, effects = "race_code:party_cd", conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "< 46864", "2" = "46864 - 52798", "3" = "52798 - 64509", "4" ="> 64509")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Race", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p2$labels$fill <- "Party"
p2$labels$colour <- "Party"
p2 = as.grob(p2)

p3 <- plot( conditional_effects(binary_model, effects = "gender_code:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "< 46864", "2" = "46864 - 52798", "3" = "52798 - 64509", "4" ="> 64509")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Gender", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p3$labels$fill <- "Binned Age"
p3$labels$colour <- "Binned Age"
p3 = as.grob(p3)

p4 <- plot( conditional_effects(binary_model, effects = "party_cd:age_binned",conditions = conditions),
     facet_args = list(labeller = labeller(cond__ = c("1" = "< 46864", "2" = "46864 - 52798", "3" = "52798 - 64509", "4" ="> 64509")), ncol = 2),
          plot=FALSE)[[1]] + labs(x = "Party", y = "Fitted Probabilities") + theme(axis.text=element_text(size=8), axis.title=element_text(size=14))
p4$labels$fill <- "Binned Age"
p4$labels$colour <- "Binned Age"
p4 = as.grob(p4)
grid.arrange(grobs = list(p1, p2, p3, p4), ncol = 2)
```


# Traceplots

```{r traceplots, echo = F, warning = F, message = F, fig.align="center"}
# Traceplots

post <- posterior_samples(binary_model, add_chain = T)

n_to_plot <- 4-1
for(i in seq(1, ncol(post)-3-n_to_plot, n_to_plot)) {
  post0 <- post[, c(i:(i+n_to_plot), length(post)-1, length(post))]
  p <- post0 %>% 
    #select(-lp__) %>% 
    gather(key, value, -chain, -iter) %>% 
    mutate(chain = as.character(chain)) %>% 
    
    ggplot(aes(x = iter, y = value, group = chain, color = chain)) +
    geom_line(size = 1/15) +
    scale_color_manual(values = c("#80A0C7", "#B1934A", "#A65141", "#EEDA9D")) +
    scale_x_continuous(NULL, breaks = c(1001, 5000)) +
    ylab(NULL) +
    #theme_pearl_earring +
    theme(legend.position  = c(.825, .06),
          legend.direction = "horizontal") +
    facet_wrap(~key, ncol = 1, scales = "free_y")
  print(p)
}
```

\pagebreak

# Sensitivity Analysis Model Output

## Model with More Informative Priors

```{r include=FALSE, cache = TRUE}
priors <- c(set_prior("normal(0,3)", class = "Intercept"),
            set_prior("normal(0,3)", class = "b"),
            set_prior("normal(0.5,3)", class = "b", coef = "age_binned30M44"),
            set_prior("normal(0.75,3)", class = "b", coef = "age_binned45M59"),
            set_prior("normal(1,3)", class = "b", coef = "age_binned60P"),
            set_prior("normal(-0.5,3)", class = "b", coef = "gender_codeM" ),
            set_prior("normal(-0.5,3)", class = "b", coef = "race_codeBlack" ),
            set_prior("normal(-1,3)", class = "b", coef = "race_codeOther" ),
            set_prior("normal(-0.5,3)", class = "b", coef = "party_cdOther" ),
            set_prior("normal(0.5,3)", class = "b", coef = "med_inc_binned46864M52798" ),
            set_prior("normal(0.5,3)", class = "b", coef = "med_inc_binned52798M64509" ),
            set_prior("normal(1,3)", class = "b", coef = "med_inc_binned>64509" ))


binary_model_newpriors <-
  brm(data = voter_grouped, family = binomial,
      votes | trials(n) ~ 1 + med_inc_binned + gender_code + race_code + age_binned + party_cd + gender_code:party_cd + race_code:party_cd + gender_code:age_binned + party_cd:age_binned,
      iter = 2500, warmup = 500, cores = 2, chains = 2,
      seed = 10,
      prior=priors)

```

```{r echo=FALSE}
#summary(binary_model_newpriors)

coef_table2 = round(fixef(binary_model_newpriors),2)
colnames(coef_table2) = c("Estimate", "Std. Error", "2.5% Quantile", "97.5% Quantile")
#rownames(coef_table2) = c("Intercept", "Median Income > 64,509", "Median Income 46,864-52,798", "Median Income 52,798-64,509", "Gender Male", "Gender Unspecified", "Race Black", "Race Other", "Age 30-44", "Age 45-59", "Age 60+", "Party Republican", "Party Other", "Gender Male:Party Republican", "Gender Unspecified:Party Republican", "Gender Male:Party Other", "Gender Unspecified:Party Other", "Race Black:Party Republican", "Race Other:Party Republican",  "Race Black:Party Other", "Race Other:Party Other",  "Gender Male:Age 30-44", "Gender Unspecified:Age 30-44", "Gender Male:Age 45-59", "Gender Unspecified:Age 45-59", "Gender Male:Age 60+", "Gender Unspecified:Age 60+", "Age 30-44:Party Republican", "Age 45-59:Party Republican", "Age 60+:Party Republican", "Age 30-44:Party Other", "Age 45-59:Party Other", "Age 60+:Party Other")
kable(coef_table2) 

#prior_summary(binary_model_newpriors)
#saveRDS(binary_model_newpriors, "grouped_model_no_randeff_newpriors_whole_dataset.rds")
```

\pagebreak

## Model with Random Effect for Congressional District

```{r echo=FALSE}
#summary(randeff_model)

coef_table3 = round(fixef(randeff_model),2)
colnames(coef_table3) = c("Estimate", "Std. Error", "2.5% Quantile", "97.5% Quantile")
#rownames(coef_table3) = c("Intercept", "Median Income > 64,509", "Median Income 46,864-52,798", "Median Income 52,798-64,509", "Gender Male", "Gender Unspecified", "Race Black", "Race Other", "Age 30-44", "Age 45-59", "Age 60+", "Party Republican", "Party Other", "Gender Male:Party Republican", "Gender Unspecified:Party Republican", "Gender Male:Party Other", "Gender Unspecified:Party Other", "Race Black:Party Republican", "Race Other:Party Republican",  "Race Black:Party Other", "Race Other:Party Other",  "Gender Male:Age 30-44", "Gender Unspecified:Age 30-44", "Gender Male:Age 45-59", "Gender Unspecified:Age 45-59", "Gender Male:Age 60+", "Gender Unspecified:Age 60+", "Age 30-44:Party Republican", "Age 45-59:Party Republican", "Age 60+:Party Republican", "Age 30-44:Party Other", "Age 45-59:Party Other", "Age 60+:Party Other")
kable(coef_table3) 
#ranef(randeff_model)
group_sd_obj = VarCorr(randeff_model)
group_sd = group_sd_obj$cong_dist_abbrv$sd[1]
```

The group-level standard deviation is `r round(group_sd, 3)`.

\pagebreak

## Frequentist Model

```{r include=FALSE, cache = T}
freq_model = glm(cbind(votes, n-votes) ~ med_inc_binned + gender_code + race_code + age_binned + party_cd + gender_code:party_cd + race_code:party_cd + gender_code:age_binned + party_cd:age_binned, data=voter_grouped, family="binomial")
```

```{r include=FALSE}
freq_summary = summary(freq_model)
freq_coefs = freq_summary$coefficients[,1:2]
#list(summary(freq_model))
freq_ci = confint(freq_model)
```

```{r echo=FALSE}
freq_output = cbind(freq_coefs, freq_ci)
kable(freq_output, digits=2) 
```

\pagebreak
